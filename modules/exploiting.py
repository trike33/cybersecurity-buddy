import sys
import os
import shutil
import subprocess
import re
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, 
    QLineEdit, QTableWidget, QTableWidgetItem, QHeaderView, 
    QSplitter, QTextEdit, QFrame, QTabWidget, QMessageBox, 
    QComboBox, QProgressBar
)
from PyQt5.QtCore import Qt, QThread, pyqtSignal
from PyQt5.QtGui import QFont, QColor, QSyntaxHighlighter, QTextCharFormat

# ---------------------------------------------------------
# 1. WORKER THREADS
# ---------------------------------------------------------

class SearchWorker(QThread):
    """Runs searchsploit in the background."""
    results_found = pyqtSignal(list)
    error_occurred = pyqtSignal(str)

    def __init__(self, query):
        super().__init__()
        self.query = query

    def run(self):
        # Format: searchsploit <query> --json is ideal, but standard output is safer for compatibility
        # We will use standard output and parse the pipes
        cmd = f"searchsploit \"{self.query}\""
        try:
            process = subprocess.Popen(
                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True
            )
            output, _ = process.communicate()
            
            results = []
            lines = output.split('\n')
            
            # Simple parser for searchsploit table output
            # Skip headers (usually lines with ----)
            for line in lines:
                if "|" in line and "Path" not in line and "---" not in line:
                    parts = line.split("|")
                    if len(parts) >= 2:
                        title = parts[0].strip()
                        path = parts[1].strip()
                        results.append((title, path))
            
            self.results_found.emit(results)

        except Exception as e:
            self.error_occurred.emit(str(e))

class ExecutionWorker(QThread):
    """Runs the exploit script."""
    output_signal = pyqtSignal(str)
    finished_signal = pyqtSignal()

    def __init__(self, command, cwd):
        super().__init__()
        self.command = command
        self.cwd = cwd
        self.process = None
        self.is_running = True

    def run(self):
        try:
            # Force unbuffered output for real-time feed
            self.process = subprocess.Popen(
                self.command, shell=True, cwd=self.cwd,
                stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
                text=True, bufsize=1, preexec_fn=os.setsid
            )
            
            for line in iter(self.process.stdout.readline, ''):
                if not self.is_running: break
                self.output_signal.emit(line.rstrip())
                
            self.process.stdout.close()
            self.process.wait()
            self.finished_signal.emit()
        except Exception as e:
            self.output_signal.emit(f"[!] Execution Error: {str(e)}")

    def stop(self):
        self.is_running = False
        if self.process:
            try:
                os.killpg(os.getpgid(self.process.pid), 15) # SIGTERM
            except:
                pass

# ---------------------------------------------------------
# 2. UI COMPONENTS
# ---------------------------------------------------------

class Step1_Search(QWidget):
    """Step 1: Search and Select Exploit"""
    exploit_selected = pyqtSignal(str, str) # title, path

    def __init__(self):
        super().__init__()
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        
        # Header
        lbl = QLabel("1. Search Vulnerability Database")
        lbl.setStyleSheet("color: #00d2ff; font-weight: bold; font-size: 14px;")
        layout.addWidget(lbl)

        # Search Bar
        h_search = QHBoxLayout()
        self.inp_search = QLineEdit()
        self.inp_search.setPlaceholderText("e.g. Apache 2.4, Windows SMB, CVE-2017...")
        self.inp_search.setStyleSheet("background: #222; color: white; padding: 8px; border: 1px solid #444;")
        self.inp_search.returnPressed.connect(self.do_search)
        
        btn_search = QPushButton("Search")
        btn_search.setStyleSheet("background: #007bff; color: white; padding: 8px; font-weight: bold;")
        btn_search.clicked.connect(self.do_search)
        
        h_search.addWidget(self.inp_search)
        h_search.addWidget(btn_search)
        layout.addLayout(h_search)

        # Results Table
        self.table = QTableWidget()
        self.table.setColumnCount(2)
        self.table.setHorizontalHeaderLabels(["Exploit Title", "Path / Type"])
        self.table.horizontalHeader().setSectionResizeMode(0, QHeaderView.Stretch)
        self.table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)
        self.table.setSelectionBehavior(QTableWidget.SelectRows)
        self.table.setStyleSheet("""
            QTableWidget { background: #1e1e2f; color: #eee; gridline-color: #333; border: 1px solid #444; }
            QHeaderView::section { background: #2f2f40; color: #aaa; padding: 4px; border: none; }
            QTableWidget::item:selected { background: #00d2ff; color: #000; }
        """)
        self.table.doubleClicked.connect(self.on_row_double_clicked)
        layout.addWidget(self.table)
        
        # Info
        layout.addWidget(QLabel("Double-click a result to edit/launch.", styleSheet="color: #666; font-style: italic;"))

    def do_search(self):
        query = self.inp_search.text().strip()
        if not query: return
        
        self.table.setRowCount(0)
        self.worker = SearchWorker(query)
        self.worker.results_found.connect(self.populate_table)
        self.worker.start()

    def populate_table(self, results):
        if not results:
            self.table.setRowCount(0)
            return
            
        self.table.setRowCount(len(results))
        for i, (title, path) in enumerate(results):
            self.table.setItem(i, 0, QTableWidgetItem(title))
            self.table.setItem(i, 1, QTableWidgetItem(path))

    def on_row_double_clicked(self):
        r = self.table.currentRow()
        if r >= 0:
            title = self.table.item(r, 0).text()
            path = self.table.item(r, 1).text()
            self.exploit_selected.emit(title, path)

class Step2_Editor(QWidget):
    """Step 2: Inspect and Edit Code"""
    launch_requested = pyqtSignal(str) # Path to launch

    def __init__(self, workspace_dir):
        super().__init__()
        self.workspace_dir = workspace_dir
        self.current_file = None
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 10, 0, 0)
        
        # Toolbar
        bar = QHBoxLayout()
        self.lbl_file = QLabel("No file loaded")
        self.lbl_file.setStyleSheet("color: #ffc107; font-weight: bold;")
        
        btn_save = QPushButton("Save Changes")
        btn_save.setFixedWidth(120)
        btn_save.clicked.connect(self.save_file)
        btn_save.setStyleSheet("background: #28a745; color: white;")

        btn_launch = QPushButton("Step 3: Launch >")
        btn_launch.setFixedWidth(120)
        btn_launch.setStyleSheet("background: #6610f2; color: white; font-weight: bold;")
        btn_launch.clicked.connect(self.request_launch)

        bar.addWidget(QLabel("Editing: "))
        bar.addWidget(self.lbl_file)
        bar.addStretch()
        bar.addWidget(btn_save)
        bar.addWidget(btn_launch)
        layout.addLayout(bar)

        # Editor
        self.editor = QTextEdit()
        self.editor.setFont(QFont("Consolas", 10))
        self.editor.setStyleSheet("""
            QTextEdit { 
                background: #15151a; color: #a9b7c6; 
                border: 1px solid #444; 
                selection-background-color: #214283;
            }
        """)
        layout.addWidget(self.editor)

    def load_exploit(self, title, partial_path):
        """
        1. Finds full path using searchsploit -p if needed, or assumes standard paths.
        2. Copies to workspace.
        3. Loads text.
        """
        # Resolve full path
        full_path = ""
        # Standard Kali paths
        bases = ["/usr/share/exploitdb/", "/opt/exploitdb/"]
        
        found = False
        for b in bases:
            possible = os.path.join(b, partial_path)
            if os.path.exists(possible):
                full_path = possible
                found = True
                break
        
        if not found:
            # Try plain exists
            if os.path.exists(partial_path):
                full_path = partial_path
            else:
                self.editor.setText(f"# Error: Could not locate file locally at {partial_path}\n# Ensure exploitdb is installed.")
                return

        # Copy to workspace
        filename = os.path.basename(full_path)
        dest = os.path.join(self.workspace_dir, filename)
        
        try:
            shutil.copy(full_path, dest)
            self.current_file = dest
            self.lbl_file.setText(filename)
            
            with open(dest, 'r', errors='ignore') as f:
                self.editor.setText(f.read())
        except Exception as e:
            self.editor.setText(f"# Error copying file: {e}")

    def save_file(self):
        if self.current_file:
            try:
                with open(self.current_file, 'w') as f:
                    f.write(self.editor.toPlainText())
                # Flash effect or status bar could go here
            except Exception as e:
                print(f"Error saving: {e}")

    def request_launch(self):
        if self.current_file:
            self.save_file() # Auto save before run
            self.launch_requested.emit(self.current_file)

class Step3_Launcher(QWidget):
    """Step 3: Configure Arguments and Execute"""
    def __init__(self):
        super().__init__()
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 10, 0, 0)
        
        # Config Bar
        h_cfg = QHBoxLayout()
        h_cfg.addWidget(QLabel("Interpreter:"))
        
        self.combo_int = QComboBox()
        self.combo_int.addItems(["Auto-Detect", "python3", "python2", "ruby", "perl", "bash"])
        h_cfg.addWidget(self.combo_int)
        
        h_cfg.addWidget(QLabel("Args:"))
        self.inp_args = QLineEdit()
        self.inp_args.setPlaceholderText("<IP> <PORT> etc...")
        h_cfg.addWidget(self.inp_args)
        
        self.btn_run = QPushButton("EXECUTE")
        self.btn_run.setStyleSheet("background: #dc3545; color: white; font-weight: bold; padding: 5px 15px;")
        self.btn_run.clicked.connect(self.run_exploit)
        h_cfg.addWidget(self.btn_run)
        
        self.btn_stop = QPushButton("STOP")
        self.btn_stop.clicked.connect(self.stop_exploit)
        h_cfg.addWidget(self.btn_stop)
        
        layout.addLayout(h_cfg)

        # Beautified Output Console
        self.console = QTextEdit()
        self.console.setReadOnly(True)
        self.console.setStyleSheet("""
            QTextEdit {
                background-color: #0c0c0c;
                color: #00ff00;
                font-family: "Consolas", "Monospace";
                font-size: 11px;
                border: 2px solid #333;
                border-radius: 4px;
                padding: 5px;
            }
        """)
        layout.addWidget(self.console)

        self.worker = None
        self.target_file = None

    def setup_launch(self, file_path):
        self.target_file = file_path
        self.console.clear()
        self.console.append(f"[*] Loaded: {os.path.basename(file_path)}")
        self.console.append("[*] Ready to launch. Set arguments above if needed.")
        
        # Heuristic for interpreter
        ext = os.path.splitext(file_path)[1]
        if ext == ".py": self.combo_int.setCurrentText("python3")
        elif ext == ".rb": self.combo_int.setCurrentText("ruby")
        elif ext == ".pl": self.combo_int.setCurrentText("perl")
        elif ext == ".sh": self.combo_int.setCurrentText("bash")
        else: self.combo_int.setCurrentText("Auto-Detect")

    def run_exploit(self):
        if not self.target_file: return
        
        interpreter = self.combo_int.currentText()
        if interpreter == "Auto-Detect":
            # Simple fallback
            if self.target_file.endswith(".py"): interpreter = "python3"
            elif self.target_file.endswith(".rb"): interpreter = "ruby"
            elif self.target_file.endswith(".pl"): interpreter = "perl"
            else: interpreter = "bash"

        args = self.inp_args.text()
        cmd = f"{interpreter} \"{self.target_file}\" {args}"
        
        self.console.append(f"\n> {cmd}")
        self.console.append("-" * 40)
        
        cwd = os.path.dirname(self.target_file)
        
        if self.worker and self.worker.isRunning():
            self.worker.stop()
        
        self.worker = ExecutionWorker(cmd, cwd)
        self.worker.output_signal.connect(self.append_log)
        self.worker.finished_signal.connect(lambda: self.console.append("\n[*] Execution Finished."))
        self.worker.start()

    def append_log(self, text):
        self.console.append(text)
        # Auto scroll
        sb = self.console.verticalScrollBar()
        sb.setValue(sb.maximum())

    def stop_exploit(self):
        if self.worker and self.worker.isRunning():
            self.worker.stop()
            self.console.append("\n[!] Process Killed by User.")

# ---------------------------------------------------------
# 3. MAIN TAB WIDGET
# ---------------------------------------------------------

class ExploitingWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # Setup Workspace
        self.workspace = os.path.join(os.getcwd(), "workspace_exploits")
        if not os.path.exists(self.workspace):
            os.makedirs(self.workspace)
            
        self.init_ui()

    def init_ui(self):
        main_layout = QVBoxLayout(self)
        
        # Main Splitter: Left (Search) vs Right (Edit/Run)
        splitter = QSplitter(Qt.Horizontal)
        splitter.setHandleWidth(2)
        
        # --- LEFT: Search ---
        self.step1 = Step1_Search()
        self.step1.exploit_selected.connect(self.on_exploit_selected)
        
        left_container = QWidget()
        l_layout = QVBoxLayout(left_container)
        l_layout.setContentsMargins(5, 5, 5, 5)
        l_layout.addWidget(self.step1)
        
        splitter.addWidget(left_container)
        
        # --- RIGHT: Tabs (Edit -> Run) ---
        self.right_tabs = QTabWidget()
        self.right_tabs.setStyleSheet("""
            QTabWidget::pane { border: 1px solid #444; background: #1e1e2f; }
            QTabBar::tab { background: #2f2f40; color: #aaa; padding: 10px 20px; }
            QTabBar::tab:selected { background: #6610f2; color: white; font-weight: bold; }
        """)
        
        self.step2 = Step2_Editor(self.workspace)
        self.step2.launch_requested.connect(self.on_launch_requested)
        
        self.step3 = Step3_Launcher()
        
        self.right_tabs.addTab(self.step2, "2. Code Inspector")
        self.right_tabs.addTab(self.step3, "3. Console / Launcher")
        
        splitter.addWidget(self.right_tabs)
        
        # Ratio
        splitter.setSizes([350, 700])
        main_layout.addWidget(splitter)

    def on_exploit_selected(self, title, path):
        # 1. Switch tab to editor
        self.right_tabs.setCurrentIndex(0)
        # 2. Load file
        self.step2.load_exploit(title, path)

    def on_launch_requested(self, local_path):
        # 1. Switch tab to launcher
        self.right_tabs.setCurrentIndex(1)
        # 2. Setup launcher
        self.step3.setup_launch(local_path)