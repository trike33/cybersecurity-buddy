import sys
import os
import shutil
import subprocess
import re
import sqlite3
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, 
    QLineEdit, QTableWidget, QTableWidgetItem, QHeaderView, 
    QSplitter, QTextEdit, QFrame, QTabWidget, QMessageBox, 
    QComboBox, QProgressBar, QAbstractItemView, QListWidget
)
from PyQt5.QtCore import Qt, QThread, pyqtSignal, QRegExp
from PyQt5.QtGui import QFont, QColor, QSyntaxHighlighter, QTextCharFormat

# ---------------------------------------------------------
# 1. HELPERS & WORKERS
# ---------------------------------------------------------

def clean_ansi(text):
    """Removes ANSI escape codes from text."""
    ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
    return ansi_escape.sub('', text)

def resolve_exploit_path(partial_path):
    """
    Locates the full path of an exploit.
    Searchsploit results usually return partial paths like 'linux/remote/1234.c'.
    We check standard Kali ExploitDB locations.
    """
    # Standard bases in Kali / ExploitDB structure
    # Usually: /usr/share/exploitdb/exploits/ OR /usr/share/exploitdb/shellcodes/
    bases = [
        "/usr/share/exploitdb/exploits",
        "/usr/share/exploitdb/shellcodes",
        "/usr/share/exploitdb",
        "/opt/exploitdb/exploits",
        "/opt/exploitdb/shellcodes",
        "/opt/exploitdb"
    ]
    
    # 1. Try joining base + partial
    for b in bases:
        possible = os.path.join(b, partial_path)
        if os.path.exists(possible):
            return possible
            
    # 2. Fallback: Check if absolute or relative to cwd
    if os.path.exists(partial_path):
        return partial_path
        
    return None

class ExploitHighlighter(QSyntaxHighlighter):
    """Simple syntax highlighter for Python/Ruby/Shell scripts."""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.highlightingRules = []

        # Formats
        keywordFormat = QTextCharFormat()
        keywordFormat.setForeground(QColor("#ff79c6")) # Pink
        keywordFormat.setFontWeight(QFont.Bold)

        commentFormat = QTextCharFormat()
        commentFormat.setForeground(QColor("#6272a4")) # Grey-Blue
        
        stringFormat = QTextCharFormat()
        stringFormat.setForeground(QColor("#f1fa8c")) # Yellow

        # Rules
        keywords = [
            "def", "class", "import", "from", "return", "if", "else", "elif",
            "while", "for", "in", "print", "try", "except", "use", "require",
            "my", "local", "sub", "void", "int", "char", "struct", "include"
        ]
        
        for word in keywords:
            pattern = QRegExp(r"\b" + word + r"\b")
            self.highlightingRules.append((pattern, keywordFormat))

        self.highlightingRules.append((QRegExp(r"\".*\""), stringFormat))
        self.highlightingRules.append((QRegExp(r"\'.*\'"), stringFormat))
        self.highlightingRules.append((QRegExp(r"#[^\n]*"), commentFormat))
        self.highlightingRules.append((QRegExp(r"//[^\n]*"), commentFormat))
        self.highlightingRules.append((QRegExp(r"/\*.*\*/"), commentFormat))

    def highlightBlock(self, text):
        for pattern, format in self.highlightingRules:
            expression = QRegExp(pattern)
            index = expression.indexIn(text)
            while index >= 0:
                length = expression.matchedLength()
                self.setFormat(index, length, format)
                index = expression.indexIn(text, index + length)

class SearchWorker(QThread):
    results_found = pyqtSignal(list)
    error_occurred = pyqtSignal(str)

    def __init__(self, query):
        super().__init__()
        self.query = query

    def run(self):
        # We use -t (title) to search titles, standard output
        cmd = f"searchsploit \"{self.query}\""
        try:
            process = subprocess.Popen(
                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True
            )
            output, _ = process.communicate()
            clean_output = clean_ansi(output)
            results = []
            
            for line in clean_output.split('\n'):
                if "----------------" in line or "Exploit Title" in line: continue
                # Basic parser for "Title | Path"
                if "|" in line:
                    parts = line.split("|")
                    if len(parts) >= 2:
                        title = parts[0].strip()
                        path = parts[1].strip()
                        if title and path and "Path" not in path:
                            results.append((title, path))
            
            self.results_found.emit(results)
        except Exception as e:
            self.error_occurred.emit(str(e))

class ExecutionWorker(QThread):
    output_signal = pyqtSignal(str)
    finished_signal = pyqtSignal()

    def __init__(self, command, cwd):
        super().__init__()
        self.command = command
        self.cwd = cwd
        self.process = None
        self.is_running = True

    def run(self):
        try:
            self.process = subprocess.Popen(
                self.command, shell=True, cwd=self.cwd,
                stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
                text=True, bufsize=1, preexec_fn=os.setsid
            )
            for line in iter(self.process.stdout.readline, ''):
                if not self.is_running: break
                self.output_signal.emit(line.rstrip())
            self.process.stdout.close()
            self.process.wait()
            self.finished_signal.emit()
        except Exception as e:
            self.output_signal.emit(f"[!] Error: {str(e)}")

    def stop(self):
        self.is_running = False
        if self.process:
            try: os.killpg(os.getpgid(self.process.pid), 15)
            except: pass

# ---------------------------------------------------------
# 2. UI COMPONENTS
# ---------------------------------------------------------

class Step1_SearchPreview(QWidget):
    edit_requested = pyqtSignal(str, str)

    def __init__(self):
        super().__init__()
        self.setStyleSheet("QLabel { font-size: 13px; } QPushButton { font-size: 12px; }")
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        
        # 1. Search Bar
        header = QHBoxLayout()
        lbl_title = QLabel("1. Search & Preview")
        lbl_title.setStyleSheet("color: #00d2ff; font-weight: bold; font-size: 15px;")
        header.addWidget(lbl_title)
        
        self.inp_search = QLineEdit()
        self.inp_search.setPlaceholderText("Search exploits (e.g. 'apache 2.4', 'windows smb')...")
        self.inp_search.setStyleSheet("background: #2b2b3b; color: white; padding: 8px; border: 1px solid #444; font-size: 13px;")
        self.inp_search.returnPressed.connect(self.do_search)
        header.addWidget(self.inp_search)
        
        btn_search = QPushButton("Search")
        btn_search.setStyleSheet("background: #007bff; color: white; padding: 8px 15px; font-weight: bold;")
        btn_search.clicked.connect(self.do_search)
        header.addWidget(btn_search)
        layout.addLayout(header)

        # 2. Splitter
        self.splitter = QSplitter(Qt.Vertical)
        self.splitter.setHandleWidth(4)
        self.splitter.setStyleSheet("QSplitter::handle { background-color: #444; }")

        # -- Top: Table --
        self.table = QTableWidget()
        self.table.setColumnCount(2)
        self.table.setHorizontalHeaderLabels(["Exploit Title", "Path"])
        self.table.horizontalHeader().setSectionResizeMode(0, QHeaderView.Stretch)
        self.table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)
        self.table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.table.setStyleSheet("""
            QTableWidget { background: #2b2b3b; color: #eee; gridline-color: #333; border: none; font-size: 12px; }
            QHeaderView::section { background: #3e3e4e; color: #aaa; padding: 6px; border: none; font-weight: bold; }
            QTableWidget::item:selected { background: #00d2ff; color: #000; }
        """)
        self.table.itemClicked.connect(self.on_row_clicked)
        self.table.doubleClicked.connect(self.on_row_double_clicked)
        self.splitter.addWidget(self.table)

        # -- Bottom: Preview --
        preview_group = QFrame()
        pv_layout = QVBoxLayout(preview_group)
        pv_layout.setContentsMargins(0, 0, 0, 0)
        
        pv_header = QLabel("  Quick Preview (Read-Only)")
        pv_header.setStyleSheet("background-color: #3e3e4e; color: #ffc107; font-weight: bold; padding: 8px; font-size: 13px;")
        pv_layout.addWidget(pv_header)
        
        self.txt_preview = QTextEdit()
        self.txt_preview.setReadOnly(True)
        self.txt_preview.setFont(QFont("Consolas", 11))
        self.txt_preview.setStyleSheet("""
            QTextEdit {
                background-color: #2b2b3b; 
                color: #f8f8f2; 
                border: none;
                padding: 10px;
            }
        """)
        self.highlighter = ExploitHighlighter(self.txt_preview.document())
        pv_layout.addWidget(self.txt_preview)
        
        self.splitter.addWidget(preview_group)
        self.splitter.setSizes([250, 450]) 
        
        layout.addWidget(self.splitter)
        layout.addWidget(QLabel("Single-click to preview. Double-click to Copy to Project & Edit.", styleSheet="color: #888; font-size: 12px; margin-top: 5px;"))

    def do_search(self):
        query = self.inp_search.text().strip()
        if not query: return
        
        self.table.setRowCount(0)
        self.txt_preview.clear()
        self.inp_search.setEnabled(False)
        self.table.setEnabled(False)
        
        self.worker = SearchWorker(query)
        self.worker.results_found.connect(self.populate_table)
        self.worker.error_occurred.connect(lambda e: QMessageBox.warning(self, "Error", e))
        self.worker.finished.connect(lambda: [self.inp_search.setEnabled(True), self.table.setEnabled(True)])
        self.worker.start()

    def populate_table(self, results):
        self.table.setRowCount(len(results))
        if not results:
            QMessageBox.information(self, "Search", "No results found.")
            return

        for i, (title, path) in enumerate(results):
            self.table.setItem(i, 0, QTableWidgetItem(title))
            self.table.setItem(i, 1, QTableWidgetItem(path))

    def on_row_clicked(self):
        r = self.table.currentRow()
        if r < 0: return
        
        path_fragment = self.table.item(r, 1).text()
        full_path = resolve_exploit_path(path_fragment)
        
        if full_path and os.path.exists(full_path):
            try:
                with open(full_path, 'r', errors='replace') as f:
                    content = f.read(8000)
                    if len(content) == 8000: content += "\n\n...[Preview Truncated]..."
                    self.txt_preview.setText(content)
            except Exception as e:
                self.txt_preview.setText(f"# Error reading file: {e}")
        else:
            self.txt_preview.setText(f"# File not found at expected path: {path_fragment}\n# Full path checked: {full_path}")

    def on_row_double_clicked(self):
        r = self.table.currentRow()
        if r >= 0:
            title = self.table.item(r, 0).text()
            path = self.table.item(r, 1).text()
            self.edit_requested.emit(title, path)

class Step2_Editor(QWidget):
    launch_requested = pyqtSignal(str) 

    def __init__(self, workspace_dir):
        super().__init__()
        self.setStyleSheet("QLabel { font-size: 13px; } QPushButton { font-size: 12px; }")
        self.workspace_dir = workspace_dir
        
        # Ensure workspace exists
        if not os.path.exists(self.workspace_dir):
            try:
                os.makedirs(self.workspace_dir)
            except OSError:
                pass

        self.current_file = None
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 10, 0, 0)
        
        bar = QHBoxLayout()
        self.lbl_file = QLabel("No file loaded")
        self.lbl_file.setStyleSheet("color: #ffc107; font-weight: bold; font-size: 14px;")
        
        btn_save = QPushButton("Save Changes")
        btn_save.clicked.connect(self.save_file)
        btn_save.setStyleSheet("background: #28a745; color: white; padding: 8px;")

        btn_launch = QPushButton("Step 3: Launch >")
        btn_launch.setStyleSheet("background: #6610f2; color: white; font-weight: bold; padding: 8px;")
        btn_launch.clicked.connect(self.request_launch)

        bar.addWidget(QLabel("Editing: "))
        bar.addWidget(self.lbl_file)
        bar.addStretch()
        bar.addWidget(btn_save)
        bar.addWidget(btn_launch)
        layout.addLayout(bar)

        self.editor = QTextEdit()
        self.editor.setFont(QFont("Consolas", 11))
        self.editor.setLineWrapMode(QTextEdit.NoWrap)
        self.editor.setStyleSheet("""
            QTextEdit { 
                background: #2b2b3b; color: #a9b7c6; 
                border: 1px solid #444; 
                selection-background-color: #214283;
            }
        """)
        self.highlighter = ExploitHighlighter(self.editor.document())
        layout.addWidget(self.editor)

    def load_exploit(self, title, partial_path):
        full_path = resolve_exploit_path(partial_path)
        if not full_path or not os.path.exists(full_path):
            self.editor.setText(f"# Error: Could not locate file locally.\n# Checked path: {full_path or partial_path}")
            return

        filename = os.path.basename(full_path)
        dest = os.path.join(self.workspace_dir, filename)
        
        try:
            shutil.copy(full_path, dest)
            self.current_file = dest
            self.lbl_file.setText(filename)
            with open(dest, 'r', errors='ignore') as f:
                self.editor.setText(f.read())
        except Exception as e:
            self.editor.setText(f"# Error copying file to project workspace: {e}")

    def save_file(self):
        if self.current_file:
            try:
                with open(self.current_file, 'w') as f:
                    f.write(self.editor.toPlainText())
            except Exception: pass

    def request_launch(self):
        if self.current_file:
            self.save_file()
            self.launch_requested.emit(self.current_file)

class Step3_Launcher(QWidget):
    def __init__(self):
        super().__init__()
        self.setStyleSheet("QLabel { font-size: 13px; } QPushButton { font-size: 12px; }")
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 10, 0, 0)
        
        h_cfg = QHBoxLayout()
        h_cfg.addWidget(QLabel("Interpreter:"))
        self.combo_int = QComboBox()
        self.combo_int.addItems(["Auto-Detect", "python3", "python2", "ruby", "perl", "bash", "gcc"])
        self.combo_int.setStyleSheet("padding: 5px; background: #2b2b3b; color: white;")
        h_cfg.addWidget(self.combo_int)
        
        h_cfg.addWidget(QLabel("Args:"))
        self.inp_args = QLineEdit()
        self.inp_args.setPlaceholderText("<IP> <PORT> etc...")
        self.inp_args.setStyleSheet("padding: 5px; background: #2b2b3b; color: white; border: 1px solid #555;")
        h_cfg.addWidget(self.inp_args)
        
        self.btn_run = QPushButton("EXECUTE")
        self.btn_run.setStyleSheet("background: #dc3545; color: white; font-weight: bold; padding: 6px 15px;")
        self.btn_run.clicked.connect(self.run_exploit)
        h_cfg.addWidget(self.btn_run)
        
        self.btn_stop = QPushButton("STOP")
        self.btn_stop.setStyleSheet("padding: 6px;")
        self.btn_stop.clicked.connect(self.stop_exploit)
        h_cfg.addWidget(self.btn_stop)
        layout.addLayout(h_cfg)

        self.console = QTextEdit()
        self.console.setReadOnly(True)
        self.console.setStyleSheet("""
            QTextEdit {
                background-color: #2b2b3b; color: #00ff00;
                font-family: "Consolas", "Monospace"; font-size: 12px;
                border: 2px solid #333; padding: 5px;
            }
        """)
        layout.addWidget(self.console)
        self.worker = None
        self.target_file = None

    def setup_launch(self, file_path):
        self.target_file = file_path
        self.console.clear()
        self.console.append(f"[*] Loaded: {os.path.basename(file_path)}")
        self.console.append("[*] Ready to launch. Set arguments above if needed.")
        
        ext = os.path.splitext(file_path)[1]
        if ext == ".py": self.combo_int.setCurrentText("python3")
        elif ext == ".rb": self.combo_int.setCurrentText("ruby")
        elif ext == ".pl": self.combo_int.setCurrentText("perl")
        elif ext == ".sh": self.combo_int.setCurrentText("bash")
        elif ext == ".c": self.combo_int.setCurrentText("gcc")
        else: self.combo_int.setCurrentText("Auto-Detect")

    def run_exploit(self):
        if not self.target_file: return
        interpreter = self.combo_int.currentText()
        
        # Simple Compilation Logic for C files
        if interpreter == "gcc" or (interpreter == "Auto-Detect" and self.target_file.endswith(".c")):
            self.console.append("[*] Compiling C source...")
            out_bin = self.target_file.replace(".c", ".out")
            compile_cmd = f"gcc \"{self.target_file}\" -o \"{out_bin}\""
            
            # Run compilation synchronously for simplicity (or spawn worker)
            try:
                subprocess.run(compile_cmd, shell=True, check=True, stderr=subprocess.PIPE)
                self.console.append(f"[*] Compilation Success: {out_bin}")
                # Update target to the binary
                run_cmd = f"\"{out_bin}\" {self.inp_args.text()}"
                self.start_worker(run_cmd, os.path.dirname(self.target_file))
            except subprocess.CalledProcessError as e:
                self.console.append(f"[!] Compilation Failed:\n{e.stderr}")
            return

        if interpreter == "Auto-Detect":
            if self.target_file.endswith(".py"): interpreter = "python3"
            elif self.target_file.endswith(".rb"): interpreter = "ruby"
            elif self.target_file.endswith(".pl"): interpreter = "perl"
            else: interpreter = "bash"

        args = self.inp_args.text()
        cmd = f"{interpreter} \"{self.target_file}\" {args}"
        self.start_worker(cmd, os.path.dirname(self.target_file))

    def start_worker(self, cmd, cwd):
        self.console.append(f"\n> {cmd}")
        self.console.append("-" * 40)
        
        if self.worker and self.worker.isRunning(): self.worker.stop()
        
        self.worker = ExecutionWorker(cmd, cwd)
        self.worker.output_signal.connect(self.append_log)
        self.worker.finished_signal.connect(lambda: self.console.append("\n[*] Execution Finished."))
        self.worker.start()

    def append_log(self, text):
        self.console.append(text)
        sb = self.console.verticalScrollBar()
        sb.setValue(sb.maximum())

    def stop_exploit(self):
        if self.worker and self.worker.isRunning():
            self.worker.stop()
            self.console.append("\n[!] Process Killed by User.")

class ExploitingWidget(QWidget):
    def __init__(self, project_path, parent=None):
        super().__init__(parent)
        self.project_path = project_path
        self.db_path = os.path.join(self.project_path, "network_information.db")
        self.workspace = os.path.join(self.project_path, "exploits")
        self.init_ui()

    def init_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(5, 5, 5, 5)

        # --- Top Compact Bulk Search Bar ---
        top_bar = QFrame()
        top_bar.setStyleSheet("background: #2b2b3b; border-bottom: 1px solid #6610f2; border-radius: 4px;")
        top_layout = QHBoxLayout(top_bar)
        
        lbl_icon = QLabel("üîç")
        top_layout.addWidget(lbl_icon)
        
        lbl_desc = QLabel("<b>Bulk Analysis:</b> Query Searchsploit for all detected service versions")
        lbl_desc.setStyleSheet("color: #aaa; margin-right: 20px;")
        top_layout.addWidget(lbl_desc)
        
        self.btn_bulk_search = QPushButton("RUN BULK VERSION SEARCH")
        self.btn_bulk_search.setStyleSheet("""
            QPushButton { background: #6610f2; color: white; font-weight: bold; padding: 8px 20px; border-radius: 4px; }
            QPushButton:hover { background: #7a22ff; }
            QPushButton:disabled { background: #444; color: #888; }
        """)
        self.btn_bulk_search.clicked.connect(self.run_bulk_version_search)
        top_layout.addWidget(self.btn_bulk_search)
        
        top_layout.addStretch()
        main_layout.addWidget(top_bar)

        # --- Main Layout (Non-Split design for editing) ---
        self.tabs = QTabWidget()
        self.tabs.setStyleSheet("""
            QTabWidget::pane { border: 1px solid #444; background: #1e1e2f; }
            QTabBar::tab { background: #2f2f40; color: #aaa; padding: 12px 30px; font-weight: bold; }
            QTabBar::tab:selected { background: #6610f2; color: white; }
        """)

        # Integration with existing Step components
        self.step1 = Step1_SearchPreview()
        self.step1.edit_requested.connect(self.on_exploit_selected)
        
        self.step2 = Step2_Editor(self.workspace)
        self.step2.launch_requested.connect(self.on_launch_requested)
        
        self.step3 = Step3_Launcher()
        
        # Add Steps as Tabs to maintain a focused single-view workflow
        self.tabs.addTab(self.step1, "1. Search & Preview")
        self.tabs.addTab(self.step2, "2. Inspector / Editor")
        self.tabs.addTab(self.step3, "3. Launcher")
        
        main_layout.addWidget(self.tabs)

    def run_bulk_version_search(self):
        """Extracts every version from the DB and feeds them to Step 1 sequentially."""
        if not os.path.exists(self.db_path):
            QMessageBox.warning(self, "Missing Data", "Network database not found. Please run Nmap first.")
            return

        versions_to_search = set()
        try:
            conn = sqlite3.connect(self.db_path)
            cur = conn.cursor()
            # As implemented previously, versions are stored pipe-separated
            cur.execute("SELECT versions FROM hosts")
            for row in cur.fetchall():
                if row[0]:
                    # Filter out 'n/a' and empty strings
                    parts = [v.strip() for v in row[0].split('|') if v.strip() and v.lower() != 'n/a']
                    versions_to_search.update(parts)
            conn.close()
        except Exception as e:
            QMessageBox.critical(self, "DB Error", f"Could not read versions: {e}")
            return

        if not versions_to_search:
            QMessageBox.information(self, "No Versions", "No service versions found in the database.")
            return

        # Switch to Search Tab and clear results
        self.tabs.setCurrentIndex(0)
        self.step1.table.setRowCount(0)
        self.step1.txt_preview.clear()
        
        # We search for each version and append to the table
        self.btn_bulk_search.setEnabled(False)
        self.btn_bulk_search.setText(f"Searching {len(versions_to_search)} versions...")
        
        self.completed_searches = 0
        self.total_to_search = len(versions_to_search)

        for version in versions_to_search:
            # We skip highly generic strings like 'http' to avoid clutter
            if len(version) < 4: continue 
            
            worker = SearchWorker(version)
            worker.results_found.connect(self.append_bulk_results)
            worker.finished.connect(self.track_bulk_progress)
            worker.start()
            # Keep a reference to prevent garbage collection
            if not hasattr(self, 'active_workers'): self.active_workers = []
            self.active_workers.append(worker)

    def append_bulk_results(self, results):
        """Callback to add results to the Step 1 table without clearing existing rows."""
        current_row = self.step1.table.rowCount()
        self.step1.table.setRowCount(current_row + len(results))
        for i, (title, path) in enumerate(results):
            self.step1.table.setItem(current_row + i, 0, QTableWidgetItem(title))
            self.step1.table.setItem(current_row + i, 1, QTableWidgetItem(path))

    def track_bulk_progress(self):
        self.completed_searches += 1
        if self.completed_searches >= self.total_to_search:
            self.btn_bulk_search.setEnabled(True)
            self.btn_bulk_search.setText("RUN BULK VERSION SEARCH")
            self.active_workers = [] # Clear references

    def on_exploit_selected(self, title, path):
        self.tabs.setCurrentIndex(0)
        self.step2.load_exploit(title, path)

    def on_launch_requested(self, local_path):
        self.tabs.setCurrentIndex(1)
        self.step3.setup_launch(local_path)
