import sys
import os
import shutil
import subprocess
import re
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, 
    QLineEdit, QTableWidget, QTableWidgetItem, QHeaderView, 
    QSplitter, QTextEdit, QFrame, QTabWidget, QMessageBox, 
    QComboBox, QProgressBar, QAbstractItemView
)
from PyQt5.QtCore import Qt, QThread, pyqtSignal, QRegExp
from PyQt5.QtGui import QFont, QColor, QSyntaxHighlighter, QTextCharFormat

# ---------------------------------------------------------
# 1. HELPERS & WORKERS
# ---------------------------------------------------------

def clean_ansi(text):
    """Removes ANSI escape codes from text."""
    ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
    return ansi_escape.sub('', text)

def resolve_exploit_path(partial_path):
    """
    Locates the full path of an exploit.
    Searchsploit results usually return partial paths like 'linux/remote/1234.c'.
    We check standard Kali ExploitDB locations.
    """
    # Standard bases in Kali / ExploitDB structure
    # Usually: /usr/share/exploitdb/exploits/ OR /usr/share/exploitdb/shellcodes/
    bases = [
        "/usr/share/exploitdb/exploits",
        "/usr/share/exploitdb/shellcodes",
        "/usr/share/exploitdb",
        "/opt/exploitdb/exploits",
        "/opt/exploitdb/shellcodes",
        "/opt/exploitdb"
    ]
    
    # 1. Try joining base + partial
    for b in bases:
        possible = os.path.join(b, partial_path)
        if os.path.exists(possible):
            return possible
            
    # 2. Fallback: Check if absolute or relative to cwd
    if os.path.exists(partial_path):
        return partial_path
        
    return None

class ExploitHighlighter(QSyntaxHighlighter):
    """Simple syntax highlighter for Python/Ruby/Shell scripts."""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.highlightingRules = []

        # Formats
        keywordFormat = QTextCharFormat()
        keywordFormat.setForeground(QColor("#ff79c6")) # Pink
        keywordFormat.setFontWeight(QFont.Bold)

        commentFormat = QTextCharFormat()
        commentFormat.setForeground(QColor("#6272a4")) # Grey-Blue
        
        stringFormat = QTextCharFormat()
        stringFormat.setForeground(QColor("#f1fa8c")) # Yellow

        # Rules
        keywords = [
            "def", "class", "import", "from", "return", "if", "else", "elif",
            "while", "for", "in", "print", "try", "except", "use", "require",
            "my", "local", "sub", "void", "int", "char", "struct", "include"
        ]
        
        for word in keywords:
            pattern = QRegExp(r"\b" + word + r"\b")
            self.highlightingRules.append((pattern, keywordFormat))

        self.highlightingRules.append((QRegExp(r"\".*\""), stringFormat))
        self.highlightingRules.append((QRegExp(r"\'.*\'"), stringFormat))
        self.highlightingRules.append((QRegExp(r"#[^\n]*"), commentFormat))
        self.highlightingRules.append((QRegExp(r"//[^\n]*"), commentFormat))
        self.highlightingRules.append((QRegExp(r"/\*.*\*/"), commentFormat))

    def highlightBlock(self, text):
        for pattern, format in self.highlightingRules:
            expression = QRegExp(pattern)
            index = expression.indexIn(text)
            while index >= 0:
                length = expression.matchedLength()
                self.setFormat(index, length, format)
                index = expression.indexIn(text, index + length)

class SearchWorker(QThread):
    results_found = pyqtSignal(list)
    error_occurred = pyqtSignal(str)

    def __init__(self, query):
        super().__init__()
        self.query = query

    def run(self):
        # We use -t (title) to search titles, standard output
        cmd = f"searchsploit \"{self.query}\""
        try:
            process = subprocess.Popen(
                cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True
            )
            output, _ = process.communicate()
            clean_output = clean_ansi(output)
            results = []
            
            for line in clean_output.split('\n'):
                if "----------------" in line or "Exploit Title" in line: continue
                # Basic parser for "Title | Path"
                if "|" in line:
                    parts = line.split("|")
                    if len(parts) >= 2:
                        title = parts[0].strip()
                        path = parts[1].strip()
                        if title and path and "Path" not in path:
                            results.append((title, path))
            
            self.results_found.emit(results)
        except Exception as e:
            self.error_occurred.emit(str(e))

class ExecutionWorker(QThread):
    output_signal = pyqtSignal(str)
    finished_signal = pyqtSignal()

    def __init__(self, command, cwd):
        super().__init__()
        self.command = command
        self.cwd = cwd
        self.process = None
        self.is_running = True

    def run(self):
        try:
            self.process = subprocess.Popen(
                self.command, shell=True, cwd=self.cwd,
                stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
                text=True, bufsize=1, preexec_fn=os.setsid
            )
            for line in iter(self.process.stdout.readline, ''):
                if not self.is_running: break
                self.output_signal.emit(line.rstrip())
            self.process.stdout.close()
            self.process.wait()
            self.finished_signal.emit()
        except Exception as e:
            self.output_signal.emit(f"[!] Error: {str(e)}")

    def stop(self):
        self.is_running = False
        if self.process:
            try: os.killpg(os.getpgid(self.process.pid), 15)
            except: pass

# ---------------------------------------------------------
# 2. UI COMPONENTS
# ---------------------------------------------------------

class Step1_SearchPreview(QWidget):
    edit_requested = pyqtSignal(str, str)

    def __init__(self):
        super().__init__()
        self.setStyleSheet("QLabel { font-size: 13px; } QPushButton { font-size: 12px; }")
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        
        # 1. Search Bar
        header = QHBoxLayout()
        lbl_title = QLabel("1. Search & Preview")
        lbl_title.setStyleSheet("color: #00d2ff; font-weight: bold; font-size: 15px;")
        header.addWidget(lbl_title)
        
        self.inp_search = QLineEdit()
        self.inp_search.setPlaceholderText("Search exploits (e.g. 'apache 2.4', 'windows smb')...")
        self.inp_search.setStyleSheet("background: #2b2b3b; color: white; padding: 8px; border: 1px solid #444; font-size: 13px;")
        self.inp_search.returnPressed.connect(self.do_search)
        header.addWidget(self.inp_search)
        
        btn_search = QPushButton("Search")
        btn_search.setStyleSheet("background: #007bff; color: white; padding: 8px 15px; font-weight: bold;")
        btn_search.clicked.connect(self.do_search)
        header.addWidget(btn_search)
        layout.addLayout(header)

        # 2. Splitter
        self.splitter = QSplitter(Qt.Vertical)
        self.splitter.setHandleWidth(4)
        self.splitter.setStyleSheet("QSplitter::handle { background-color: #444; }")

        # -- Top: Table --
        self.table = QTableWidget()
        self.table.setColumnCount(2)
        self.table.setHorizontalHeaderLabels(["Exploit Title", "Path"])
        self.table.horizontalHeader().setSectionResizeMode(0, QHeaderView.Stretch)
        self.table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)
        self.table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.table.setStyleSheet("""
            QTableWidget { background: #2b2b3b; color: #eee; gridline-color: #333; border: none; font-size: 12px; }
            QHeaderView::section { background: #3e3e4e; color: #aaa; padding: 6px; border: none; font-weight: bold; }
            QTableWidget::item:selected { background: #00d2ff; color: #000; }
        """)
        self.table.itemClicked.connect(self.on_row_clicked)
        self.table.doubleClicked.connect(self.on_row_double_clicked)
        self.splitter.addWidget(self.table)

        # -- Bottom: Preview --
        preview_group = QFrame()
        pv_layout = QVBoxLayout(preview_group)
        pv_layout.setContentsMargins(0, 0, 0, 0)
        
        pv_header = QLabel("  Quick Preview (Read-Only)")
        pv_header.setStyleSheet("background-color: #3e3e4e; color: #ffc107; font-weight: bold; padding: 8px; font-size: 13px;")
        pv_layout.addWidget(pv_header)
        
        self.txt_preview = QTextEdit()
        self.txt_preview.setReadOnly(True)
        self.txt_preview.setFont(QFont("Consolas", 11))
        self.txt_preview.setStyleSheet("""
            QTextEdit {
                background-color: #2b2b3b; 
                color: #f8f8f2; 
                border: none;
                padding: 10px;
            }
        """)
        self.highlighter = ExploitHighlighter(self.txt_preview.document())
        pv_layout.addWidget(self.txt_preview)
        
        self.splitter.addWidget(preview_group)
        self.splitter.setSizes([250, 450]) 
        
        layout.addWidget(self.splitter)
        layout.addWidget(QLabel("Single-click to preview. Double-click to Copy to Project & Edit.", styleSheet="color: #888; font-size: 12px; margin-top: 5px;"))

    def do_search(self):
        query = self.inp_search.text().strip()
        if not query: return
        
        self.table.setRowCount(0)
        self.txt_preview.clear()
        self.inp_search.setEnabled(False)
        self.table.setEnabled(False)
        
        self.worker = SearchWorker(query)
        self.worker.results_found.connect(self.populate_table)
        self.worker.error_occurred.connect(lambda e: QMessageBox.warning(self, "Error", e))
        self.worker.finished.connect(lambda: [self.inp_search.setEnabled(True), self.table.setEnabled(True)])
        self.worker.start()

    def populate_table(self, results):
        self.table.setRowCount(len(results))
        if not results:
            QMessageBox.information(self, "Search", "No results found.")
            return

        for i, (title, path) in enumerate(results):
            self.table.setItem(i, 0, QTableWidgetItem(title))
            self.table.setItem(i, 1, QTableWidgetItem(path))

    def on_row_clicked(self):
        r = self.table.currentRow()
        if r < 0: return
        
        path_fragment = self.table.item(r, 1).text()
        full_path = resolve_exploit_path(path_fragment)
        
        if full_path and os.path.exists(full_path):
            try:
                with open(full_path, 'r', errors='replace') as f:
                    content = f.read(8000)
                    if len(content) == 8000: content += "\n\n...[Preview Truncated]..."
                    self.txt_preview.setText(content)
            except Exception as e:
                self.txt_preview.setText(f"# Error reading file: {e}")
        else:
            self.txt_preview.setText(f"# File not found at expected path: {path_fragment}\n# Full path checked: {full_path}")

    def on_row_double_clicked(self):
        r = self.table.currentRow()
        if r >= 0:
            title = self.table.item(r, 0).text()
            path = self.table.item(r, 1).text()
            self.edit_requested.emit(title, path)

class Step2_Editor(QWidget):
    launch_requested = pyqtSignal(str) 

    def __init__(self, workspace_dir):
        super().__init__()
        self.setStyleSheet("QLabel { font-size: 13px; } QPushButton { font-size: 12px; }")
        self.workspace_dir = workspace_dir
        
        # Ensure workspace exists
        if not os.path.exists(self.workspace_dir):
            try:
                os.makedirs(self.workspace_dir)
            except OSError:
                pass

        self.current_file = None
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 10, 0, 0)
        
        bar = QHBoxLayout()
        self.lbl_file = QLabel("No file loaded")
        self.lbl_file.setStyleSheet("color: #ffc107; font-weight: bold; font-size: 14px;")
        
        btn_save = QPushButton("Save Changes")
        btn_save.clicked.connect(self.save_file)
        btn_save.setStyleSheet("background: #28a745; color: white; padding: 8px;")

        btn_launch = QPushButton("Step 3: Launch >")
        btn_launch.setStyleSheet("background: #6610f2; color: white; font-weight: bold; padding: 8px;")
        btn_launch.clicked.connect(self.request_launch)

        bar.addWidget(QLabel("Editing: "))
        bar.addWidget(self.lbl_file)
        bar.addStretch()
        bar.addWidget(btn_save)
        bar.addWidget(btn_launch)
        layout.addLayout(bar)

        self.editor = QTextEdit()
        self.editor.setFont(QFont("Consolas", 11))
        self.editor.setLineWrapMode(QTextEdit.NoWrap)
        self.editor.setStyleSheet("""
            QTextEdit { 
                background: #2b2b3b; color: #a9b7c6; 
                border: 1px solid #444; 
                selection-background-color: #214283;
            }
        """)
        self.highlighter = ExploitHighlighter(self.editor.document())
        layout.addWidget(self.editor)

    def load_exploit(self, title, partial_path):
        full_path = resolve_exploit_path(partial_path)
        if not full_path or not os.path.exists(full_path):
            self.editor.setText(f"# Error: Could not locate file locally.\n# Checked path: {full_path or partial_path}")
            return

        filename = os.path.basename(full_path)
        dest = os.path.join(self.workspace_dir, filename)
        
        try:
            shutil.copy(full_path, dest)
            self.current_file = dest
            self.lbl_file.setText(filename)
            with open(dest, 'r', errors='ignore') as f:
                self.editor.setText(f.read())
        except Exception as e:
            self.editor.setText(f"# Error copying file to project workspace: {e}")

    def save_file(self):
        if self.current_file:
            try:
                with open(self.current_file, 'w') as f:
                    f.write(self.editor.toPlainText())
            except Exception: pass

    def request_launch(self):
        if self.current_file:
            self.save_file()
            self.launch_requested.emit(self.current_file)

class Step3_Launcher(QWidget):
    def __init__(self):
        super().__init__()
        self.setStyleSheet("QLabel { font-size: 13px; } QPushButton { font-size: 12px; }")
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 10, 0, 0)
        
        h_cfg = QHBoxLayout()
        h_cfg.addWidget(QLabel("Interpreter:"))
        self.combo_int = QComboBox()
        self.combo_int.addItems(["Auto-Detect", "python3", "python2", "ruby", "perl", "bash", "gcc"])
        self.combo_int.setStyleSheet("padding: 5px; background: #2b2b3b; color: white;")
        h_cfg.addWidget(self.combo_int)
        
        h_cfg.addWidget(QLabel("Args:"))
        self.inp_args = QLineEdit()
        self.inp_args.setPlaceholderText("<IP> <PORT> etc...")
        self.inp_args.setStyleSheet("padding: 5px; background: #2b2b3b; color: white; border: 1px solid #555;")
        h_cfg.addWidget(self.inp_args)
        
        self.btn_run = QPushButton("EXECUTE")
        self.btn_run.setStyleSheet("background: #dc3545; color: white; font-weight: bold; padding: 6px 15px;")
        self.btn_run.clicked.connect(self.run_exploit)
        h_cfg.addWidget(self.btn_run)
        
        self.btn_stop = QPushButton("STOP")
        self.btn_stop.setStyleSheet("padding: 6px;")
        self.btn_stop.clicked.connect(self.stop_exploit)
        h_cfg.addWidget(self.btn_stop)
        layout.addLayout(h_cfg)

        self.console = QTextEdit()
        self.console.setReadOnly(True)
        self.console.setStyleSheet("""
            QTextEdit {
                background-color: #2b2b3b; color: #00ff00;
                font-family: "Consolas", "Monospace"; font-size: 12px;
                border: 2px solid #333; padding: 5px;
            }
        """)
        layout.addWidget(self.console)
        self.worker = None
        self.target_file = None

    def setup_launch(self, file_path):
        self.target_file = file_path
        self.console.clear()
        self.console.append(f"[*] Loaded: {os.path.basename(file_path)}")
        self.console.append("[*] Ready to launch. Set arguments above if needed.")
        
        ext = os.path.splitext(file_path)[1]
        if ext == ".py": self.combo_int.setCurrentText("python3")
        elif ext == ".rb": self.combo_int.setCurrentText("ruby")
        elif ext == ".pl": self.combo_int.setCurrentText("perl")
        elif ext == ".sh": self.combo_int.setCurrentText("bash")
        elif ext == ".c": self.combo_int.setCurrentText("gcc")
        else: self.combo_int.setCurrentText("Auto-Detect")

    def run_exploit(self):
        if not self.target_file: return
        interpreter = self.combo_int.currentText()
        
        # Simple Compilation Logic for C files
        if interpreter == "gcc" or (interpreter == "Auto-Detect" and self.target_file.endswith(".c")):
            self.console.append("[*] Compiling C source...")
            out_bin = self.target_file.replace(".c", ".out")
            compile_cmd = f"gcc \"{self.target_file}\" -o \"{out_bin}\""
            
            # Run compilation synchronously for simplicity (or spawn worker)
            try:
                subprocess.run(compile_cmd, shell=True, check=True, stderr=subprocess.PIPE)
                self.console.append(f"[*] Compilation Success: {out_bin}")
                # Update target to the binary
                run_cmd = f"\"{out_bin}\" {self.inp_args.text()}"
                self.start_worker(run_cmd, os.path.dirname(self.target_file))
            except subprocess.CalledProcessError as e:
                self.console.append(f"[!] Compilation Failed:\n{e.stderr}")
            return

        if interpreter == "Auto-Detect":
            if self.target_file.endswith(".py"): interpreter = "python3"
            elif self.target_file.endswith(".rb"): interpreter = "ruby"
            elif self.target_file.endswith(".pl"): interpreter = "perl"
            else: interpreter = "bash"

        args = self.inp_args.text()
        cmd = f"{interpreter} \"{self.target_file}\" {args}"
        self.start_worker(cmd, os.path.dirname(self.target_file))

    def start_worker(self, cmd, cwd):
        self.console.append(f"\n> {cmd}")
        self.console.append("-" * 40)
        
        if self.worker and self.worker.isRunning(): self.worker.stop()
        
        self.worker = ExecutionWorker(cmd, cwd)
        self.worker.output_signal.connect(self.append_log)
        self.worker.finished_signal.connect(lambda: self.console.append("\n[*] Execution Finished."))
        self.worker.start()

    def append_log(self, text):
        self.console.append(text)
        sb = self.console.verticalScrollBar()
        sb.setValue(sb.maximum())

    def stop_exploit(self):
        if self.worker and self.worker.isRunning():
            self.worker.stop()
            self.console.append("\n[!] Process Killed by User.")

class ExploitingWidget(QWidget):
    """
    Main widget for the Exploiting Module.
    Accepts project_path to save exploits in project_folder/exploits/.
    """
    def __init__(self, project_path, parent=None):
        super().__init__(parent)
        self.project_path = project_path
        # Define exploit workspace within the project folder
        self.workspace = os.path.join(self.project_path, "exploits")
        
        self.init_ui()

    def init_ui(self):
        main_layout = QVBoxLayout(self)
        splitter = QSplitter(Qt.Horizontal)
        splitter.setHandleWidth(2)
        
        self.step1 = Step1_SearchPreview()
        self.step1.edit_requested.connect(self.on_exploit_selected)
        
        left_container = QWidget()
        l_layout = QVBoxLayout(left_container)
        l_layout.setContentsMargins(5, 5, 5, 5)
        l_layout.addWidget(self.step1)
        splitter.addWidget(left_container)
        
        self.right_tabs = QTabWidget()
        self.right_tabs.setStyleSheet("""
            QTabWidget::pane { border: 1px solid #444; background: #1e1e2f; }
            QTabBar::tab { background: #2f2f40; color: #aaa; padding: 10px 20px; font-size: 13px; font-weight: bold; }
            QTabBar::tab:selected { background: #6610f2; color: white; }
        """)
        
        self.step2 = Step2_Editor(self.workspace)
        self.step2.launch_requested.connect(self.on_launch_requested)
        self.step3 = Step3_Launcher()
        
        self.right_tabs.addTab(self.step2, "Inspector")
        self.right_tabs.addTab(self.step3, "Launcher")
        
        splitter.addWidget(self.right_tabs)
        splitter.setSizes([350, 700])
        main_layout.addWidget(splitter)

    def on_exploit_selected(self, title, path):
        self.right_tabs.setCurrentIndex(0)
        self.step2.load_exploit(title, path)

    def on_launch_requested(self, local_path):
        self.right_tabs.setCurrentIndex(1)
        self.step3.setup_launch(local_path)